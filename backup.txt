vec3 bsdf(Triangle triangle, vec3 incomingDir, vec3 outgoingDir, vec3 normal) {
  float epsilon = 1e-5f;

  vec3 halfVector = normalize(incomingDir + outgoingDir);
  float NdotL = max(dot(normal, incomingDir), 0.0f);
  float NdotV = max(dot(normal, outgoingDir), 0.0f);
  float NdotH = max(dot(normal, halfVector), 0.0f);
  float HdotL = max(dot(halfVector, incomingDir), 0.0f);
  float HdotV = max(dot(halfVector, outgoingDir), 0.0f);

    // Microfacet distribution (D) using GGX (Trowbridge-Reitz) model
 /*  float alpha = triangle.roughness * triangle.roughness;
  float alpha2 = alpha * alpha;
  float denom = max(NdotH * NdotH * (alpha2 - 1.0f) + 1.0f, epsilon);
  float D = alpha2 / (M_PI * denom * denom); */
  // D = pow((pow(NdotH, 2.0f) - 1.0f) / (alpha2 * pow(NdotH, 2.0f)), 2.0f) / (M_PI * alpha2 * pow(NdotH, 2.0f));

  float alpha = triangle.roughness * triangle.roughness;
  float alpha2 = alpha * alpha;

  float D = alpha2 / (M_PI * (((NdotH * NdotH) * (alpha2 - 1.0f)) + 1.0f) * (((NdotH * NdotH) * (alpha2 - 1.0f)) + 1.0f));

/*   float alpha = triangle.roughness * triangle.roughness;
  float alpha2 = alpha * alpha;
  float D = (alpha2 - 1.0f) / (M_PI * pow((NdotH * NdotH * (alpha2 - 1.0f) + 1.0f), 2.0f)); */

    // Geometry term (G) using Smith's method
/*   float G1 = 2.0f * NdotH * NdotV / HdotV;
  float G2 = 2.0f * NdotH * NdotL / HdotL;
  float G = min(min(G1, G2), 1.0f); */
/*   float G1 = 2.0f * NdotV / (NdotV + sqrt(alpha2 + (1.0f - alpha2) * (NdotV * NdotV)));
  float G2 = 2.0f * NdotL / (NdotL + sqrt(alpha2 + (1.0f - alpha2) * (NdotL * NdotL)));
  float G = G1 * G2;
  */
/*   vec3 k_s = vec3(pow(triangle.roughness + 1.0f, 2.0f) / 8.0f);
  float G = min(1.0f, min(2.0f * NdotH * NdotV / HdotV, 2.0f * NdotH * NdotL / HdotV)); */
// float kDirect = ((alpha + 1.0f) * (alpha + 1.0f)) / (8.0f); // v1??
  float kDirect = ((triangle.roughness + 1.0f) * (triangle.roughness + 1.0f)) / (8.0f);
  float Gv = (NdotV) / (NdotV * (1.0f - kDirect) + kDirect);
  float Gl = (NdotL) / (NdotL * (1.0f - kDirect) + kDirect);
  float G = Gv * Gl;

    // Fresnel (F) - Schlick's approximation
  vec3 F0 = vec3(0.04f); // Dielectric F0
  // F0 = vec3(pow((1.0f - triangle.ior) / (1.0f + triangle.ior), 2.0f));

  // if(triangle.metallic > 0.0f) {
    // F0 = triangle.color; // Metallic surfaces use the base color as F0
  // F0 = vec3(pow((1.0f - triangle.ior) / (1.0f + triangle.ior), 2.0f));
  F0 = (mix(F0, triangle.color, triangle.metallic));

  // }
  vec3 F = F0 + (1.0f - F0) * pow(clamp(1.0f - HdotV, 0.0f, 1.0f), 5.0f);//F0 + (1.0f - F0) * pow(clamp(1.0f - NdotV, 0.0f, 1.0f), 5.0f);

  // vec3 k_d = vec3(1.0f) - F;

    // Specular BRDF component
  vec3 specular = (D * G * F) / (4.0f * max(NdotL, epsilon) * max(NdotV, epsilon));

    // Diffuse BRDF component
  vec3 diffuse = triangle.color * M_1_PI; //vec3(0.0f);
  if(triangle.metallic == 0.0f) {
    diffuse = triangle.color * M_1_PI; // Lambertian reflection (1/Ï€ for energy conservation)
  }
  vec3 kD = vec3(1.0f) - F;
  kD *= 1.0f - triangle.metallic;
    // Combine specular and diffuse components
  return diffuse * kD + specular;

  // Final BRDF calculation
/*   vec3 F_res = F * G * D / max(4.0f * NdotL * NdotV, 0.001f);
  vec3 D_res = k_d * (1.0f - F) * NdotL / M_PI;
  return F_res + D_res; */

}